// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: account.proto

package proto

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on CreateAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateAccountRequestMultiError, or nil if none found.
func (m *CreateAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if m.Logo != nil {
		// no validation rules for Logo
	}

	if len(errors) > 0 {
		return CreateAccountRequestMultiError(errors)
	}

	return nil
}

// CreateAccountRequestMultiError is an error wrapping multiple validation
// errors returned by CreateAccountRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateAccountRequestMultiError) AllErrors() []error { return m }

// CreateAccountRequestValidationError is the validation error returned by
// CreateAccountRequest.Validate if the designated constraints aren't met.
type CreateAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateAccountRequestValidationError) ErrorName() string {
	return "CreateAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateAccountRequestValidationError{}

// Validate checks the field values on ListAccountsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAccountsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAccountsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListAccountsRequestMultiError, or nil if none found.
func (m *ListAccountsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAccountsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListAccountsRequestValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListAccountsRequestValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListAccountsRequestValidationError{
				field:  "Page",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AccountId

	// no validation rules for EnterpriseId

	if m.Refresh != nil {
		// no validation rules for Refresh
	}

	if len(errors) > 0 {
		return ListAccountsRequestMultiError(errors)
	}

	return nil
}

// ListAccountsRequestMultiError is an error wrapping multiple validation
// errors returned by ListAccountsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListAccountsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAccountsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAccountsRequestMultiError) AllErrors() []error { return m }

// ListAccountsRequestValidationError is the validation error returned by
// ListAccountsRequest.Validate if the designated constraints aren't met.
type ListAccountsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAccountsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAccountsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAccountsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAccountsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAccountsRequestValidationError) ErrorName() string {
	return "ListAccountsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListAccountsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAccountsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAccountsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAccountsRequestValidationError{}

// Validate checks the field values on ListAgentAccountsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAgentAccountsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAgentAccountsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListAgentAccountsRequestMultiError, or nil if none found.
func (m *ListAgentAccountsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAgentAccountsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListAgentAccountsRequestValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListAgentAccountsRequestValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListAgentAccountsRequestValidationError{
				field:  "Page",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AccountId

	// no validation rules for AccountType

	// no validation rules for EnterpriseId

	if m.Refresh != nil {
		// no validation rules for Refresh
	}

	if len(errors) > 0 {
		return ListAgentAccountsRequestMultiError(errors)
	}

	return nil
}

// ListAgentAccountsRequestMultiError is an error wrapping multiple validation
// errors returned by ListAgentAccountsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListAgentAccountsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAgentAccountsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAgentAccountsRequestMultiError) AllErrors() []error { return m }

// ListAgentAccountsRequestValidationError is the validation error returned by
// ListAgentAccountsRequest.Validate if the designated constraints aren't met.
type ListAgentAccountsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAgentAccountsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAgentAccountsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAgentAccountsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAgentAccountsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAgentAccountsRequestValidationError) ErrorName() string {
	return "ListAgentAccountsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListAgentAccountsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAgentAccountsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAgentAccountsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAgentAccountsRequestValidationError{}

// Validate checks the field values on ListAccountsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAccountsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAccountsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListAccountsResponseMultiError, or nil if none found.
func (m *ListAccountsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAccountsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListAccountsResponseValidationError{
						field:  fmt.Sprintf("Accounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListAccountsResponseValidationError{
						field:  fmt.Sprintf("Accounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListAccountsResponseValidationError{
					field:  fmt.Sprintf("Accounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListAccountsResponseValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListAccountsResponseValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListAccountsResponseValidationError{
				field:  "Page",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListAccountsResponseMultiError(errors)
	}

	return nil
}

// ListAccountsResponseMultiError is an error wrapping multiple validation
// errors returned by ListAccountsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListAccountsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAccountsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAccountsResponseMultiError) AllErrors() []error { return m }

// ListAccountsResponseValidationError is the validation error returned by
// ListAccountsResponse.Validate if the designated constraints aren't met.
type ListAccountsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAccountsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAccountsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAccountsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAccountsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAccountsResponseValidationError) ErrorName() string {
	return "ListAccountsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListAccountsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAccountsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAccountsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAccountsResponseValidationError{}

// Validate checks the field values on ImportAgentAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportAgentAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportAgentAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportAgentAccountRequestMultiError, or nil if none found.
func (m *ImportAgentAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportAgentAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for EnterpriseId

	if len(errors) > 0 {
		return ImportAgentAccountRequestMultiError(errors)
	}

	return nil
}

// ImportAgentAccountRequestMultiError is an error wrapping multiple validation
// errors returned by ImportAgentAccountRequest.ValidateAll() if the
// designated constraints aren't met.
type ImportAgentAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportAgentAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportAgentAccountRequestMultiError) AllErrors() []error { return m }

// ImportAgentAccountRequestValidationError is the validation error returned by
// ImportAgentAccountRequest.Validate if the designated constraints aren't met.
type ImportAgentAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportAgentAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportAgentAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportAgentAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportAgentAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportAgentAccountRequestValidationError) ErrorName() string {
	return "ImportAgentAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ImportAgentAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportAgentAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportAgentAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportAgentAccountRequestValidationError{}

// Validate checks the field values on ImportAgentAccountsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportAgentAccountsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportAgentAccountsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportAgentAccountsResponseMultiError, or nil if none found.
func (m *ImportAgentAccountsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportAgentAccountsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportAgentAccountsResponseValidationError{
						field:  fmt.Sprintf("Accounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportAgentAccountsResponseValidationError{
						field:  fmt.Sprintf("Accounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportAgentAccountsResponseValidationError{
					field:  fmt.Sprintf("Accounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ImportAgentAccountsResponseMultiError(errors)
	}

	return nil
}

// ImportAgentAccountsResponseMultiError is an error wrapping multiple
// validation errors returned by ImportAgentAccountsResponse.ValidateAll() if
// the designated constraints aren't met.
type ImportAgentAccountsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportAgentAccountsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportAgentAccountsResponseMultiError) AllErrors() []error { return m }

// ImportAgentAccountsResponseValidationError is the validation error returned
// by ImportAgentAccountsResponse.Validate if the designated constraints
// aren't met.
type ImportAgentAccountsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportAgentAccountsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportAgentAccountsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportAgentAccountsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportAgentAccountsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportAgentAccountsResponseValidationError) ErrorName() string {
	return "ImportAgentAccountsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ImportAgentAccountsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportAgentAccountsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportAgentAccountsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportAgentAccountsResponseValidationError{}

// Validate checks the field values on Brand with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Brand) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Brand with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BrandMultiError, or nil if none found.
func (m *Brand) ValidateAll() error {
	return m.validate(true)
}

func (m *Brand) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BrandImg

	// no validation rules for BrandName

	if len(errors) > 0 {
		return BrandMultiError(errors)
	}

	return nil
}

// BrandMultiError is an error wrapping multiple validation errors returned by
// Brand.ValidateAll() if the designated constraints aren't met.
type BrandMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BrandMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BrandMultiError) AllErrors() []error { return m }

// BrandValidationError is the validation error returned by Brand.Validate if
// the designated constraints aren't met.
type BrandValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BrandValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BrandValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BrandValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BrandValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BrandValidationError) ErrorName() string { return "BrandValidationError" }

// Error satisfies the builtin error interface
func (e BrandValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBrand.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BrandValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BrandValidationError{}

// Validate checks the field values on AdcreativeElements with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AdcreativeElements) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AdcreativeElements with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AdcreativeElementsMultiError, or nil if none found.
func (m *AdcreativeElements) ValidateAll() error {
	return m.validate(true)
}

func (m *AdcreativeElements) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBrand()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdcreativeElementsValidationError{
					field:  "Brand",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdcreativeElementsValidationError{
					field:  "Brand",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBrand()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdcreativeElementsValidationError{
				field:  "Brand",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Description

	// no validation rules for Image

	if len(errors) > 0 {
		return AdcreativeElementsMultiError(errors)
	}

	return nil
}

// AdcreativeElementsMultiError is an error wrapping multiple validation errors
// returned by AdcreativeElements.ValidateAll() if the designated constraints
// aren't met.
type AdcreativeElementsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdcreativeElementsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdcreativeElementsMultiError) AllErrors() []error { return m }

// AdcreativeElementsValidationError is the validation error returned by
// AdcreativeElements.Validate if the designated constraints aren't met.
type AdcreativeElementsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdcreativeElementsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdcreativeElementsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdcreativeElementsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdcreativeElementsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdcreativeElementsValidationError) ErrorName() string {
	return "AdcreativeElementsValidationError"
}

// Error satisfies the builtin error interface
func (e AdcreativeElementsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdcreativeElements.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdcreativeElementsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdcreativeElementsValidationError{}

// Validate checks the field values on PageSpec with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PageSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PageSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PageSpecMultiError, or nil
// if none found.
func (m *PageSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *PageSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageUrl

	// no validation rules for PageId

	if len(errors) > 0 {
		return PageSpecMultiError(errors)
	}

	return nil
}

// PageSpecMultiError is an error wrapping multiple validation errors returned
// by PageSpec.ValidateAll() if the designated constraints aren't met.
type PageSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PageSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PageSpecMultiError) AllErrors() []error { return m }

// PageSpecValidationError is the validation error returned by
// PageSpec.Validate if the designated constraints aren't met.
type PageSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PageSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PageSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PageSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PageSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PageSpecValidationError) ErrorName() string { return "PageSpecValidationError" }

// Error satisfies the builtin error interface
func (e PageSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPageSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PageSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PageSpecValidationError{}

// Validate checks the field values on Adcreative with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Adcreative) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Adcreative with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AdcreativeMultiError, or
// nil if none found.
func (m *Adcreative) ValidateAll() error {
	return m.validate(true)
}

func (m *Adcreative) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetAdcreativeElements()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdcreativeValidationError{
					field:  "AdcreativeElements",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdcreativeValidationError{
					field:  "AdcreativeElements",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAdcreativeElements()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdcreativeValidationError{
				field:  "AdcreativeElements",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Uid

	// no validation rules for AdcreativeId

	// no validation rules for AdcreativeName

	// no validation rules for AdcreativeTemplateId

	// no validation rules for CampaignId

	// no validation rules for CreativeTemplateCategory

	// no validation rules for EnableBreakthroughSiteset

	if all {
		switch v := interface{}(m.GetPageSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdcreativeValidationError{
					field:  "PageSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdcreativeValidationError{
					field:  "PageSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPageSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdcreativeValidationError{
				field:  "PageSpec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PageType

	// no validation rules for PlayablePageMaterialId

	// no validation rules for PromotedObjectId

	// no validation rules for PromotedObjectType

	if all {
		switch v := interface{}(m.GetCreatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdcreativeValidationError{
					field:  "CreatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdcreativeValidationError{
					field:  "CreatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdcreativeValidationError{
				field:  "CreatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdcreativeValidationError{
					field:  "UpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdcreativeValidationError{
					field:  "UpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdcreativeValidationError{
				field:  "UpdatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSourceCreatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdcreativeValidationError{
					field:  "SourceCreatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdcreativeValidationError{
					field:  "SourceCreatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSourceCreatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdcreativeValidationError{
				field:  "SourceCreatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSourceUpdatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdcreativeValidationError{
					field:  "SourceUpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdcreativeValidationError{
					field:  "SourceUpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSourceUpdatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdcreativeValidationError{
				field:  "SourceUpdatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AdcreativeMultiError(errors)
	}

	return nil
}

// AdcreativeMultiError is an error wrapping multiple validation errors
// returned by Adcreative.ValidateAll() if the designated constraints aren't met.
type AdcreativeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdcreativeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdcreativeMultiError) AllErrors() []error { return m }

// AdcreativeValidationError is the validation error returned by
// Adcreative.Validate if the designated constraints aren't met.
type AdcreativeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdcreativeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdcreativeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdcreativeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdcreativeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdcreativeValidationError) ErrorName() string { return "AdcreativeValidationError" }

// Error satisfies the builtin error interface
func (e AdcreativeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdcreative.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdcreativeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdcreativeValidationError{}

// Validate checks the field values on Range with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Range) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Range with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RangeMultiError, or nil if none found.
func (m *Range) ValidateAll() error {
	return m.validate(true)
}

func (m *Range) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Max

	// no validation rules for Min

	if len(errors) > 0 {
		return RangeMultiError(errors)
	}

	return nil
}

// RangeMultiError is an error wrapping multiple validation errors returned by
// Range.ValidateAll() if the designated constraints aren't met.
type RangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RangeMultiError) AllErrors() []error { return m }

// RangeValidationError is the validation error returned by Range.Validate if
// the designated constraints aren't met.
type RangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RangeValidationError) ErrorName() string { return "RangeValidationError" }

// Error satisfies the builtin error interface
func (e RangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RangeValidationError{}

// Validate checks the field values on GeoLocation with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GeoLocation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GeoLocation with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GeoLocationMultiError, or
// nil if none found.
func (m *GeoLocation) ValidateAll() error {
	return m.validate(true)
}

func (m *GeoLocation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GeoLocationMultiError(errors)
	}

	return nil
}

// GeoLocationMultiError is an error wrapping multiple validation errors
// returned by GeoLocation.ValidateAll() if the designated constraints aren't met.
type GeoLocationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GeoLocationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GeoLocationMultiError) AllErrors() []error { return m }

// GeoLocationValidationError is the validation error returned by
// GeoLocation.Validate if the designated constraints aren't met.
type GeoLocationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GeoLocationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GeoLocationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GeoLocationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GeoLocationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GeoLocationValidationError) ErrorName() string { return "GeoLocationValidationError" }

// Error satisfies the builtin error interface
func (e GeoLocationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGeoLocation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GeoLocationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GeoLocationValidationError{}

// Validate checks the field values on Targeting with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Targeting) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Targeting with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TargetingMultiError, or nil
// if none found.
func (m *Targeting) ValidateAll() error {
	return m.validate(true)
}

func (m *Targeting) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uid

	// no validation rules for Provider

	// no validation rules for ProviderId

	// no validation rules for TargetingId

	for idx, item := range m.GetAge() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TargetingValidationError{
						field:  fmt.Sprintf("Age[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TargetingValidationError{
						field:  fmt.Sprintf("Age[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TargetingValidationError{
					field:  fmt.Sprintf("Age[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetGeoLocation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TargetingValidationError{
					field:  "GeoLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TargetingValidationError{
					field:  "GeoLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGeoLocation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TargetingValidationError{
				field:  "GeoLocation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TargetingValidationError{
					field:  "CreatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TargetingValidationError{
					field:  "CreatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TargetingValidationError{
				field:  "CreatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TargetingValidationError{
					field:  "UpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TargetingValidationError{
					field:  "UpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TargetingValidationError{
				field:  "UpdatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TargetingMultiError(errors)
	}

	return nil
}

// TargetingMultiError is an error wrapping multiple validation errors returned
// by Targeting.ValidateAll() if the designated constraints aren't met.
type TargetingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TargetingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TargetingMultiError) AllErrors() []error { return m }

// TargetingValidationError is the validation error returned by
// Targeting.Validate if the designated constraints aren't met.
type TargetingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TargetingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TargetingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TargetingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TargetingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TargetingValidationError) ErrorName() string { return "TargetingValidationError" }

// Error satisfies the builtin error interface
func (e TargetingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTargeting.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TargetingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TargetingValidationError{}

// Validate checks the field values on Conversion with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Conversion) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Conversion with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConversionMultiError, or
// nil if none found.
func (m *Conversion) ValidateAll() error {
	return m.validate(true)
}

func (m *Conversion) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uid

	// no validation rules for AccessStatus

	// no validation rules for AccessType

	// no validation rules for ClaimType

	// no validation rules for ConversionId

	// no validation rules for ConversionLinkId

	// no validation rules for ConversionName

	// no validation rules for ConversionScene

	// no validation rules for CreateSourceType

	// no validation rules for FeedbackUrl

	// no validation rules for ImpressionFeedbackUrl

	// no validation rules for IsDeleted

	// no validation rules for OptimizationGoal

	// no validation rules for PromotedObjectId

	// no validation rules for SelfAttributed

	// no validation rules for SiteSetEnable

	// no validation rules for UserActionSetId

	if all {
		switch v := interface{}(m.GetCreatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConversionValidationError{
					field:  "CreatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConversionValidationError{
					field:  "CreatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConversionValidationError{
				field:  "CreatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConversionValidationError{
					field:  "UpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConversionValidationError{
					field:  "UpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConversionValidationError{
				field:  "UpdatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ConversionMultiError(errors)
	}

	return nil
}

// ConversionMultiError is an error wrapping multiple validation errors
// returned by Conversion.ValidateAll() if the designated constraints aren't met.
type ConversionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConversionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConversionMultiError) AllErrors() []error { return m }

// ConversionValidationError is the validation error returned by
// Conversion.Validate if the designated constraints aren't met.
type ConversionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConversionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConversionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConversionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConversionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConversionValidationError) ErrorName() string { return "ConversionValidationError" }

// Error satisfies the builtin error interface
func (e ConversionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConversion.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConversionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConversionValidationError{}

// Validate checks the field values on Adgroup with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Adgroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Adgroup with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AdgroupMultiError, or nil if none found.
func (m *Adgroup) ValidateAll() error {
	return m.validate(true)
}

func (m *Adgroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for AdCount

	// no validation rules for Uid

	// no validation rules for Provider

	// no validation rules for ProviderId

	// no validation rules for AdgroupName

	// no validation rules for AutomaticSiteEnabled

	// no validation rules for BeginDate

	// no validation rules for BidAmount

	// no validation rules for BidMode

	// no validation rules for BidStrategy

	// no validation rules for CampaignId

	// no validation rules for ConfiguredStatus

	// no validation rules for ConversionId

	if all {
		switch v := interface{}(m.GetConversion()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdgroupValidationError{
					field:  "Conversion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdgroupValidationError{
					field:  "Conversion",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConversion()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdgroupValidationError{
				field:  "Conversion",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SourceConversionId

	// no validation rules for CostGuaranteeMessage

	// no validation rules for CostGuaranteeStatus

	// no validation rules for DailyBudget

	// no validation rules for EndDate

	// no validation rules for ExpandEnabled

	for idx, item := range m.GetExpandTargeting() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AdgroupValidationError{
						field:  fmt.Sprintf("ExpandTargeting[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AdgroupValidationError{
						field:  fmt.Sprintf("ExpandTargeting[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AdgroupValidationError{
					field:  fmt.Sprintf("ExpandTargeting[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for OptimizationGoal

	// no validation rules for PromotedObjectType

	// no validation rules for Status

	// no validation rules for SystemStatus

	// no validation rules for TargetingId

	// no validation rules for SourceTargetingId

	if all {
		switch v := interface{}(m.GetTargeting()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdgroupValidationError{
					field:  "Targeting",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdgroupValidationError{
					field:  "Targeting",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargeting()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdgroupValidationError{
				field:  "Targeting",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TargetingTranslation

	// no validation rules for TimeSeries

	if all {
		switch v := interface{}(m.GetCreatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdgroupValidationError{
					field:  "CreatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdgroupValidationError{
					field:  "CreatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdgroupValidationError{
				field:  "CreatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdgroupValidationError{
					field:  "UpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdgroupValidationError{
					field:  "UpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdgroupValidationError{
				field:  "UpdatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSourceCreatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdgroupValidationError{
					field:  "SourceCreatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdgroupValidationError{
					field:  "SourceCreatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSourceCreatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdgroupValidationError{
				field:  "SourceCreatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSourceUpdatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdgroupValidationError{
					field:  "SourceUpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdgroupValidationError{
					field:  "SourceUpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSourceUpdatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdgroupValidationError{
				field:  "SourceUpdatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AdgroupMultiError(errors)
	}

	return nil
}

// AdgroupMultiError is an error wrapping multiple validation errors returned
// by Adgroup.ValidateAll() if the designated constraints aren't met.
type AdgroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdgroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdgroupMultiError) AllErrors() []error { return m }

// AdgroupValidationError is the validation error returned by Adgroup.Validate
// if the designated constraints aren't met.
type AdgroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdgroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdgroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdgroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdgroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdgroupValidationError) ErrorName() string { return "AdgroupValidationError" }

// Error satisfies the builtin error interface
func (e AdgroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAdgroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdgroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdgroupValidationError{}

// Validate checks the field values on Ad with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Ad) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Ad with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AdMultiError, or nil if none found.
func (m *Ad) ValidateAll() error {
	return m.validate(true)
}

func (m *Ad) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uid

	// no validation rules for Provider

	// no validation rules for ProviderId

	// no validation rules for AdName

	// no validation rules for AdsetId

	if all {
		switch v := interface{}(m.GetAdcreative()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdValidationError{
					field:  "Adcreative",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdValidationError{
					field:  "Adcreative",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAdcreative()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdValidationError{
				field:  "Adcreative",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AdcreativeId

	// no validation rules for SourceAdcreativeId

	// no validation rules for AdgroupId

	// no validation rules for SourceAdgroupId

	if all {
		switch v := interface{}(m.GetAdgroup()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdValidationError{
					field:  "Adgroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdValidationError{
					field:  "Adgroup",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAdgroup()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdValidationError{
				field:  "Adgroup",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AccountId

	// no validation rules for SourceAccountId

	if all {
		switch v := interface{}(m.GetAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdValidationError{
				field:  "Account",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CampaignId

	// no validation rules for SourceCampaignId

	// no validation rules for ClickTrackingUrl

	// no validation rules for ConfiguredStatus

	// no validation rules for ImpressionTrackingUrl

	// no validation rules for IsDeleted

	// no validation rules for IsDynamicCreative

	// no validation rules for RejectMessage

	// no validation rules for SystemStatus

	if all {
		switch v := interface{}(m.GetCreatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdValidationError{
					field:  "CreatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdValidationError{
					field:  "CreatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdValidationError{
				field:  "CreatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdValidationError{
					field:  "UpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdValidationError{
					field:  "UpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdValidationError{
				field:  "UpdatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSourceCreatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdValidationError{
					field:  "SourceCreatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdValidationError{
					field:  "SourceCreatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSourceCreatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdValidationError{
				field:  "SourceCreatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSourceUpdatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AdValidationError{
					field:  "SourceUpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AdValidationError{
					field:  "SourceUpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSourceUpdatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AdValidationError{
				field:  "SourceUpdatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AdMultiError(errors)
	}

	return nil
}

// AdMultiError is an error wrapping multiple validation errors returned by
// Ad.ValidateAll() if the designated constraints aren't met.
type AdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AdMultiError) AllErrors() []error { return m }

// AdValidationError is the validation error returned by Ad.Validate if the
// designated constraints aren't met.
type AdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AdValidationError) ErrorName() string { return "AdValidationError" }

// Error satisfies the builtin error interface
func (e AdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AdValidationError{}

// Validate checks the field values on Account with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Account) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Account with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AccountMultiError, or nil if none found.
func (m *Account) ValidateAll() error {
	return m.validate(true)
}

func (m *Account) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uid

	// no validation rules for AccountId

	// no validation rules for Role

	// no validation rules for Name

	// no validation rules for Website

	// no validation rules for CorpName

	// no validation rules for License

	// no validation rules for LicensePicture

	// no validation rules for Identity

	// no validation rules for City

	// no validation rules for ContactPerson

	// no validation rules for ContactPersonId

	if err := m._validateEmail(m.GetContactPersonEmail()); err != nil {
		err = AccountValidationError{
			field:  "ContactPersonEmail",
			reason: "value must be a valid email address",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ContactPersonPhone

	// no validation rules for Industry

	// no validation rules for Provider

	// no validation rules for AccessToken

	// no validation rules for AccessTokenExpiresIn

	if all {
		switch v := interface{}(m.GetAccessTokenExpiresAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccountValidationError{
					field:  "AccessTokenExpiresAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccountValidationError{
					field:  "AccessTokenExpiresAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccessTokenExpiresAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccountValidationError{
				field:  "AccessTokenExpiresAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RefreshToken

	// no validation rules for Status

	// no validation rules for RefreshTokenExpiresIn

	if all {
		switch v := interface{}(m.GetRefreshTokenExpiresAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccountValidationError{
					field:  "RefreshTokenExpiresAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccountValidationError{
					field:  "RefreshTokenExpiresAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefreshTokenExpiresAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccountValidationError{
				field:  "RefreshTokenExpiresAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserId

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccountValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccountValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccountValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for EnterpriseId

	if all {
		switch v := interface{}(m.GetEnterprise()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccountValidationError{
					field:  "Enterprise",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccountValidationError{
					field:  "Enterprise",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnterprise()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccountValidationError{
				field:  "Enterprise",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetEnts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AccountValidationError{
						field:  fmt.Sprintf("Ents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AccountValidationError{
						field:  fmt.Sprintf("Ents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AccountValidationError{
					field:  fmt.Sprintf("Ents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetSetting()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccountValidationError{
					field:  "Setting",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccountValidationError{
					field:  "Setting",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSetting()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccountValidationError{
				field:  "Setting",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ParentId

	if all {
		switch v := interface{}(m.GetParent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccountValidationError{
					field:  "Parent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccountValidationError{
					field:  "Parent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccountValidationError{
				field:  "Parent",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetAds() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AccountValidationError{
						field:  fmt.Sprintf("Ads[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AccountValidationError{
						field:  fmt.Sprintf("Ads[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AccountValidationError{
					field:  fmt.Sprintf("Ads[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccountValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccountValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccountValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccountValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccountValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccountValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFieldMask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccountValidationError{
					field:  "FieldMask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccountValidationError{
					field:  "FieldMask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFieldMask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccountValidationError{
				field:  "FieldMask",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AccountMultiError(errors)
	}

	return nil
}

func (m *Account) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *Account) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// AccountMultiError is an error wrapping multiple validation errors returned
// by Account.ValidateAll() if the designated constraints aren't met.
type AccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccountMultiError) AllErrors() []error { return m }

// AccountValidationError is the validation error returned by Account.Validate
// if the designated constraints aren't met.
type AccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccountValidationError) ErrorName() string { return "AccountValidationError" }

// Error satisfies the builtin error interface
func (e AccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccountValidationError{}

// Validate checks the field values on AccountSetting with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AccountSetting) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AccountSetting with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AccountSettingMultiError,
// or nil if none found.
func (m *AccountSetting) ValidateAll() error {
	return m.validate(true)
}

func (m *AccountSetting) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPdd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccountSettingValidationError{
					field:  "Pdd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccountSettingValidationError{
					field:  "Pdd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPdd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccountSettingValidationError{
				field:  "Pdd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AccountSettingMultiError(errors)
	}

	return nil
}

// AccountSettingMultiError is an error wrapping multiple validation errors
// returned by AccountSetting.ValidateAll() if the designated constraints
// aren't met.
type AccountSettingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccountSettingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccountSettingMultiError) AllErrors() []error { return m }

// AccountSettingValidationError is the validation error returned by
// AccountSetting.Validate if the designated constraints aren't met.
type AccountSettingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccountSettingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccountSettingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccountSettingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccountSettingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccountSettingValidationError) ErrorName() string { return "AccountSettingValidationError" }

// Error satisfies the builtin error interface
func (e AccountSettingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccountSetting.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccountSettingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccountSettingValidationError{}

// Validate checks the field values on UpdateAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateAccountRequestMultiError, or nil if none found.
func (m *UpdateAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	// no validation rules for Website

	// no validation rules for CorpName

	// no validation rules for License

	// no validation rules for LicensePicture

	// no validation rules for City

	// no validation rules for LegalPerson

	// no validation rules for LegalPersonId

	// no validation rules for LegalPersonPhone

	// no validation rules for Industry

	if len(errors) > 0 {
		return UpdateAccountRequestMultiError(errors)
	}

	return nil
}

// UpdateAccountRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateAccountRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateAccountRequestMultiError) AllErrors() []error { return m }

// UpdateAccountRequestValidationError is the validation error returned by
// UpdateAccountRequest.Validate if the designated constraints aren't met.
type UpdateAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateAccountRequestValidationError) ErrorName() string {
	return "UpdateAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateAccountRequestValidationError{}

// Validate checks the field values on GetAccountRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAccountRequestMultiError, or nil if none found.
func (m *GetAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for EnterpriseId

	// no validation rules for ViewToken

	if len(errors) > 0 {
		return GetAccountRequestMultiError(errors)
	}

	return nil
}

// GetAccountRequestMultiError is an error wrapping multiple validation errors
// returned by GetAccountRequest.ValidateAll() if the designated constraints
// aren't met.
type GetAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAccountRequestMultiError) AllErrors() []error { return m }

// GetAccountRequestValidationError is the validation error returned by
// GetAccountRequest.Validate if the designated constraints aren't met.
type GetAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAccountRequestValidationError) ErrorName() string {
	return "GetAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAccountRequestValidationError{}

// Validate checks the field values on DeleteAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteAccountRequestMultiError, or nil if none found.
func (m *DeleteAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeleteAccountRequestMultiError(errors)
	}

	return nil
}

// DeleteAccountRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteAccountRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteAccountRequestMultiError) AllErrors() []error { return m }

// DeleteAccountRequestValidationError is the validation error returned by
// DeleteAccountRequest.Validate if the designated constraints aren't met.
type DeleteAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteAccountRequestValidationError) ErrorName() string {
	return "DeleteAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteAccountRequestValidationError{}

// Validate checks the field values on GrantToRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GrantToRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GrantToRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GrantToRequestMultiError,
// or nil if none found.
func (m *GrantToRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GrantToRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	switch v := m.GrantTo.(type) {
	case *GrantToRequest_UserId:
		if v == nil {
			err := GrantToRequestValidationError{
				field:  "GrantTo",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for UserId
	case *GrantToRequest_EnterpriseId:
		if v == nil {
			err := GrantToRequestValidationError{
				field:  "GrantTo",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for EnterpriseId
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return GrantToRequestMultiError(errors)
	}

	return nil
}

// GrantToRequestMultiError is an error wrapping multiple validation errors
// returned by GrantToRequest.ValidateAll() if the designated constraints
// aren't met.
type GrantToRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GrantToRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GrantToRequestMultiError) AllErrors() []error { return m }

// GrantToRequestValidationError is the validation error returned by
// GrantToRequest.Validate if the designated constraints aren't met.
type GrantToRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GrantToRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GrantToRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GrantToRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GrantToRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GrantToRequestValidationError) ErrorName() string { return "GrantToRequestValidationError" }

// Error satisfies the builtin error interface
func (e GrantToRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGrantToRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GrantToRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GrantToRequestValidationError{}

// Validate checks the field values on GrantToResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GrantToResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GrantToResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GrantToResponseMultiError, or nil if none found.
func (m *GrantToResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GrantToResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Success

	if len(errors) > 0 {
		return GrantToResponseMultiError(errors)
	}

	return nil
}

// GrantToResponseMultiError is an error wrapping multiple validation errors
// returned by GrantToResponse.ValidateAll() if the designated constraints
// aren't met.
type GrantToResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GrantToResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GrantToResponseMultiError) AllErrors() []error { return m }

// GrantToResponseValidationError is the validation error returned by
// GrantToResponse.Validate if the designated constraints aren't met.
type GrantToResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GrantToResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GrantToResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GrantToResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GrantToResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GrantToResponseValidationError) ErrorName() string { return "GrantToResponseValidationError" }

// Error satisfies the builtin error interface
func (e GrantToResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGrantToResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GrantToResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GrantToResponseValidationError{}

// Validate checks the field values on RevokeFromRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RevokeFromRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RevokeFromRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RevokeFromRequestMultiError, or nil if none found.
func (m *RevokeFromRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RevokeFromRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	switch v := m.GrantTo.(type) {
	case *RevokeFromRequest_UserId:
		if v == nil {
			err := RevokeFromRequestValidationError{
				field:  "GrantTo",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for UserId
	case *RevokeFromRequest_EnterpriseId:
		if v == nil {
			err := RevokeFromRequestValidationError{
				field:  "GrantTo",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for EnterpriseId
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return RevokeFromRequestMultiError(errors)
	}

	return nil
}

// RevokeFromRequestMultiError is an error wrapping multiple validation errors
// returned by RevokeFromRequest.ValidateAll() if the designated constraints
// aren't met.
type RevokeFromRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RevokeFromRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RevokeFromRequestMultiError) AllErrors() []error { return m }

// RevokeFromRequestValidationError is the validation error returned by
// RevokeFromRequest.Validate if the designated constraints aren't met.
type RevokeFromRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RevokeFromRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RevokeFromRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RevokeFromRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RevokeFromRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RevokeFromRequestValidationError) ErrorName() string {
	return "RevokeFromRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RevokeFromRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRevokeFromRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RevokeFromRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RevokeFromRequestValidationError{}

// Validate checks the field values on RevokeFromResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RevokeFromResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RevokeFromResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RevokeFromResponseMultiError, or nil if none found.
func (m *RevokeFromResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RevokeFromResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Success

	if len(errors) > 0 {
		return RevokeFromResponseMultiError(errors)
	}

	return nil
}

// RevokeFromResponseMultiError is an error wrapping multiple validation errors
// returned by RevokeFromResponse.ValidateAll() if the designated constraints
// aren't met.
type RevokeFromResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RevokeFromResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RevokeFromResponseMultiError) AllErrors() []error { return m }

// RevokeFromResponseValidationError is the validation error returned by
// RevokeFromResponse.Validate if the designated constraints aren't met.
type RevokeFromResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RevokeFromResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RevokeFromResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RevokeFromResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RevokeFromResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RevokeFromResponseValidationError) ErrorName() string {
	return "RevokeFromResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RevokeFromResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRevokeFromResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RevokeFromResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RevokeFromResponseValidationError{}

// Validate checks the field values on ImportAuthRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ImportAuthRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportAuthRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportAuthRequestMultiError, or nil if none found.
func (m *ImportAuthRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportAuthRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Provider

	// no validation rules for Scene

	if m.EnterpriseId != nil {
		// no validation rules for EnterpriseId
	}

	if len(errors) > 0 {
		return ImportAuthRequestMultiError(errors)
	}

	return nil
}

// ImportAuthRequestMultiError is an error wrapping multiple validation errors
// returned by ImportAuthRequest.ValidateAll() if the designated constraints
// aren't met.
type ImportAuthRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportAuthRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportAuthRequestMultiError) AllErrors() []error { return m }

// ImportAuthRequestValidationError is the validation error returned by
// ImportAuthRequest.Validate if the designated constraints aren't met.
type ImportAuthRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportAuthRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportAuthRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportAuthRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportAuthRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportAuthRequestValidationError) ErrorName() string {
	return "ImportAuthRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ImportAuthRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportAuthRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportAuthRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportAuthRequestValidationError{}

// Validate checks the field values on ImportAuthResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportAuthResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportAuthResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportAuthResponseMultiError, or nil if none found.
func (m *ImportAuthResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportAuthResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AuthorizationUrl

	// no validation rules for State

	if len(errors) > 0 {
		return ImportAuthResponseMultiError(errors)
	}

	return nil
}

// ImportAuthResponseMultiError is an error wrapping multiple validation errors
// returned by ImportAuthResponse.ValidateAll() if the designated constraints
// aren't met.
type ImportAuthResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportAuthResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportAuthResponseMultiError) AllErrors() []error { return m }

// ImportAuthResponseValidationError is the validation error returned by
// ImportAuthResponse.Validate if the designated constraints aren't met.
type ImportAuthResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportAuthResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportAuthResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportAuthResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportAuthResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportAuthResponseValidationError) ErrorName() string {
	return "ImportAuthResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ImportAuthResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportAuthResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportAuthResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportAuthResponseValidationError{}

// Validate checks the field values on ImportAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportAccountRequestMultiError, or nil if none found.
func (m *ImportAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Provider

	// no validation rules for AccountId

	// no validation rules for AccessToken

	// no validation rules for AccessTokenExpiresIn

	if m.RefreshToken != nil {
		// no validation rules for RefreshToken
	}

	if m.RefreshTokenExpiresIn != nil {
		// no validation rules for RefreshTokenExpiresIn
	}

	if m.State != nil {
		// no validation rules for State
	}

	if m.EnterpriseId != nil {
		// no validation rules for EnterpriseId
	}

	if len(errors) > 0 {
		return ImportAccountRequestMultiError(errors)
	}

	return nil
}

// ImportAccountRequestMultiError is an error wrapping multiple validation
// errors returned by ImportAccountRequest.ValidateAll() if the designated
// constraints aren't met.
type ImportAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportAccountRequestMultiError) AllErrors() []error { return m }

// ImportAccountRequestValidationError is the validation error returned by
// ImportAccountRequest.Validate if the designated constraints aren't met.
type ImportAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportAccountRequestValidationError) ErrorName() string {
	return "ImportAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ImportAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportAccountRequestValidationError{}

// Validate checks the field values on ImportAccountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportAccountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportAccountResponseMultiError, or nil if none found.
func (m *ImportAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Provider

	if all {
		switch v := interface{}(m.GetAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ImportAccountResponseValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ImportAccountResponseValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ImportAccountResponseValidationError{
				field:  "Account",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ImportAccountResponseMultiError(errors)
	}

	return nil
}

// ImportAccountResponseMultiError is an error wrapping multiple validation
// errors returned by ImportAccountResponse.ValidateAll() if the designated
// constraints aren't met.
type ImportAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportAccountResponseMultiError) AllErrors() []error { return m }

// ImportAccountResponseValidationError is the validation error returned by
// ImportAccountResponse.Validate if the designated constraints aren't met.
type ImportAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportAccountResponseValidationError) ErrorName() string {
	return "ImportAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ImportAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportAccountResponseValidationError{}

// Validate checks the field values on ImportSchemasRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportSchemasRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportSchemasRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportSchemasRequestMultiError, or nil if none found.
func (m *ImportSchemasRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportSchemasRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ImportSchemasRequestMultiError(errors)
	}

	return nil
}

// ImportSchemasRequestMultiError is an error wrapping multiple validation
// errors returned by ImportSchemasRequest.ValidateAll() if the designated
// constraints aren't met.
type ImportSchemasRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportSchemasRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportSchemasRequestMultiError) AllErrors() []error { return m }

// ImportSchemasRequestValidationError is the validation error returned by
// ImportSchemasRequest.Validate if the designated constraints aren't met.
type ImportSchemasRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportSchemasRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportSchemasRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportSchemasRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportSchemasRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportSchemasRequestValidationError) ErrorName() string {
	return "ImportSchemasRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ImportSchemasRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportSchemasRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportSchemasRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportSchemasRequestValidationError{}

// Validate checks the field values on ImportSchema with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ImportSchema) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportSchema with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ImportSchemaMultiError, or
// nil if none found.
func (m *ImportSchema) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportSchema) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Provider

	// no validation rules for Title

	// no validation rules for Description

	// no validation rules for CoverPic

	// no validation rules for Type

	// no validation rules for AuthorizationUrl

	// no validation rules for TokenUrl

	// no validation rules for Scene

	// no validation rules for Disabled

	if len(errors) > 0 {
		return ImportSchemaMultiError(errors)
	}

	return nil
}

// ImportSchemaMultiError is an error wrapping multiple validation errors
// returned by ImportSchema.ValidateAll() if the designated constraints aren't met.
type ImportSchemaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportSchemaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportSchemaMultiError) AllErrors() []error { return m }

// ImportSchemaValidationError is the validation error returned by
// ImportSchema.Validate if the designated constraints aren't met.
type ImportSchemaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportSchemaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportSchemaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportSchemaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportSchemaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportSchemaValidationError) ErrorName() string { return "ImportSchemaValidationError" }

// Error satisfies the builtin error interface
func (e ImportSchemaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportSchema.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportSchemaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportSchemaValidationError{}

// Validate checks the field values on ImportSchemasResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportSchemasResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportSchemasResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportSchemasResponseMultiError, or nil if none found.
func (m *ImportSchemasResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportSchemasResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSchemas() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportSchemasResponseValidationError{
						field:  fmt.Sprintf("Schemas[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportSchemasResponseValidationError{
						field:  fmt.Sprintf("Schemas[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportSchemasResponseValidationError{
					field:  fmt.Sprintf("Schemas[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ImportSchemasResponseMultiError(errors)
	}

	return nil
}

// ImportSchemasResponseMultiError is an error wrapping multiple validation
// errors returned by ImportSchemasResponse.ValidateAll() if the designated
// constraints aren't met.
type ImportSchemasResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportSchemasResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportSchemasResponseMultiError) AllErrors() []error { return m }

// ImportSchemasResponseValidationError is the validation error returned by
// ImportSchemasResponse.Validate if the designated constraints aren't met.
type ImportSchemasResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportSchemasResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportSchemasResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportSchemasResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportSchemasResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportSchemasResponseValidationError) ErrorName() string {
	return "ImportSchemasResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ImportSchemasResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportSchemasResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportSchemasResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportSchemasResponseValidationError{}

// Validate checks the field values on ImportRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ImportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ImportRequestMultiError, or
// nil if none found.
func (m *ImportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Provider

	if len(errors) > 0 {
		return ImportRequestMultiError(errors)
	}

	return nil
}

// ImportRequestMultiError is an error wrapping multiple validation errors
// returned by ImportRequest.ValidateAll() if the designated constraints
// aren't met.
type ImportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportRequestMultiError) AllErrors() []error { return m }

// ImportRequestValidationError is the validation error returned by
// ImportRequest.Validate if the designated constraints aren't met.
type ImportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportRequestValidationError) ErrorName() string { return "ImportRequestValidationError" }

// Error satisfies the builtin error interface
func (e ImportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportRequestValidationError{}

// Validate checks the field values on ImportResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ImportResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ImportResponseMultiError,
// or nil if none found.
func (m *ImportResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AuthorizationUrl

	// no validation rules for State

	if len(errors) > 0 {
		return ImportResponseMultiError(errors)
	}

	return nil
}

// ImportResponseMultiError is an error wrapping multiple validation errors
// returned by ImportResponse.ValidateAll() if the designated constraints
// aren't met.
type ImportResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportResponseMultiError) AllErrors() []error { return m }

// ImportResponseValidationError is the validation error returned by
// ImportResponse.Validate if the designated constraints aren't met.
type ImportResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportResponseValidationError) ErrorName() string { return "ImportResponseValidationError" }

// Error satisfies the builtin error interface
func (e ImportResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportResponseValidationError{}

// Validate checks the field values on BindingAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BindingAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BindingAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BindingAccountRequestMultiError, or nil if none found.
func (m *BindingAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BindingAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	if len(errors) > 0 {
		return BindingAccountRequestMultiError(errors)
	}

	return nil
}

// BindingAccountRequestMultiError is an error wrapping multiple validation
// errors returned by BindingAccountRequest.ValidateAll() if the designated
// constraints aren't met.
type BindingAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BindingAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BindingAccountRequestMultiError) AllErrors() []error { return m }

// BindingAccountRequestValidationError is the validation error returned by
// BindingAccountRequest.Validate if the designated constraints aren't met.
type BindingAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BindingAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BindingAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BindingAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BindingAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BindingAccountRequestValidationError) ErrorName() string {
	return "BindingAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BindingAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBindingAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BindingAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BindingAccountRequestValidationError{}

// Validate checks the field values on BindingAccountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BindingAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BindingAccountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BindingAccountResponseMultiError, or nil if none found.
func (m *BindingAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BindingAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return BindingAccountResponseMultiError(errors)
	}

	return nil
}

// BindingAccountResponseMultiError is an error wrapping multiple validation
// errors returned by BindingAccountResponse.ValidateAll() if the designated
// constraints aren't met.
type BindingAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BindingAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BindingAccountResponseMultiError) AllErrors() []error { return m }

// BindingAccountResponseValidationError is the validation error returned by
// BindingAccountResponse.Validate if the designated constraints aren't met.
type BindingAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BindingAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BindingAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BindingAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BindingAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BindingAccountResponseValidationError) ErrorName() string {
	return "BindingAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BindingAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBindingAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BindingAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BindingAccountResponseValidationError{}

// Validate checks the field values on UnbindingAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnbindingAccountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnbindingAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnbindingAccountRequestMultiError, or nil if none found.
func (m *UnbindingAccountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UnbindingAccountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	if len(errors) > 0 {
		return UnbindingAccountRequestMultiError(errors)
	}

	return nil
}

// UnbindingAccountRequestMultiError is an error wrapping multiple validation
// errors returned by UnbindingAccountRequest.ValidateAll() if the designated
// constraints aren't met.
type UnbindingAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnbindingAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnbindingAccountRequestMultiError) AllErrors() []error { return m }

// UnbindingAccountRequestValidationError is the validation error returned by
// UnbindingAccountRequest.Validate if the designated constraints aren't met.
type UnbindingAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnbindingAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnbindingAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnbindingAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnbindingAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnbindingAccountRequestValidationError) ErrorName() string {
	return "UnbindingAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UnbindingAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnbindingAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnbindingAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnbindingAccountRequestValidationError{}

// Validate checks the field values on UnbindingAccountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnbindingAccountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnbindingAccountResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnbindingAccountResponseMultiError, or nil if none found.
func (m *UnbindingAccountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UnbindingAccountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	if len(errors) > 0 {
		return UnbindingAccountResponseMultiError(errors)
	}

	return nil
}

// UnbindingAccountResponseMultiError is an error wrapping multiple validation
// errors returned by UnbindingAccountResponse.ValidateAll() if the designated
// constraints aren't met.
type UnbindingAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnbindingAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnbindingAccountResponseMultiError) AllErrors() []error { return m }

// UnbindingAccountResponseValidationError is the validation error returned by
// UnbindingAccountResponse.Validate if the designated constraints aren't met.
type UnbindingAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnbindingAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnbindingAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnbindingAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnbindingAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnbindingAccountResponseValidationError) ErrorName() string {
	return "UnbindingAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UnbindingAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnbindingAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnbindingAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnbindingAccountResponseValidationError{}

// Validate checks the field values on ListUserActionSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListUserActionSetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListUserActionSetRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListUserActionSetRequestMultiError, or nil if none found.
func (m *ListUserActionSetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListUserActionSetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	if len(errors) > 0 {
		return ListUserActionSetRequestMultiError(errors)
	}

	return nil
}

// ListUserActionSetRequestMultiError is an error wrapping multiple validation
// errors returned by ListUserActionSetRequest.ValidateAll() if the designated
// constraints aren't met.
type ListUserActionSetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUserActionSetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUserActionSetRequestMultiError) AllErrors() []error { return m }

// ListUserActionSetRequestValidationError is the validation error returned by
// ListUserActionSetRequest.Validate if the designated constraints aren't met.
type ListUserActionSetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserActionSetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserActionSetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserActionSetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserActionSetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserActionSetRequestValidationError) ErrorName() string {
	return "ListUserActionSetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserActionSetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserActionSetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserActionSetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserActionSetRequestValidationError{}

// Validate checks the field values on UserActionsSetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UserActionsSetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserActionsSetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserActionsSetResponseMultiError, or nil if none found.
func (m *UserActionsSetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UserActionsSetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	for idx, item := range m.GetUserActionSetIds() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserActionsSetResponseValidationError{
						field:  fmt.Sprintf("UserActionSetIds[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserActionsSetResponseValidationError{
						field:  fmt.Sprintf("UserActionSetIds[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserActionsSetResponseValidationError{
					field:  fmt.Sprintf("UserActionSetIds[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserActionsSetResponseMultiError(errors)
	}

	return nil
}

// UserActionsSetResponseMultiError is an error wrapping multiple validation
// errors returned by UserActionsSetResponse.ValidateAll() if the designated
// constraints aren't met.
type UserActionsSetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserActionsSetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserActionsSetResponseMultiError) AllErrors() []error { return m }

// UserActionsSetResponseValidationError is the validation error returned by
// UserActionsSetResponse.Validate if the designated constraints aren't met.
type UserActionsSetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserActionsSetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserActionsSetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserActionsSetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserActionsSetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserActionsSetResponseValidationError) ErrorName() string {
	return "UserActionsSetResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UserActionsSetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserActionsSetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserActionsSetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserActionsSetResponseValidationError{}

// Validate checks the field values on UserActionSetID with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserActionSetID) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserActionSetID with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserActionSetIDMultiError, or nil if none found.
func (m *UserActionSetID) ValidateAll() error {
	return m.validate(true)
}

func (m *UserActionSetID) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ActivateStatus

	// no validation rules for CreatedTime

	// no validation rules for Description

	// no validation rules for EnableConversionClaim

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for UserActionSetId

	if len(errors) > 0 {
		return UserActionSetIDMultiError(errors)
	}

	return nil
}

// UserActionSetIDMultiError is an error wrapping multiple validation errors
// returned by UserActionSetID.ValidateAll() if the designated constraints
// aren't met.
type UserActionSetIDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserActionSetIDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserActionSetIDMultiError) AllErrors() []error { return m }

// UserActionSetIDValidationError is the validation error returned by
// UserActionSetID.Validate if the designated constraints aren't met.
type UserActionSetIDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserActionSetIDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserActionSetIDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserActionSetIDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserActionSetIDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserActionSetIDValidationError) ErrorName() string { return "UserActionSetIDValidationError" }

// Error satisfies the builtin error interface
func (e UserActionSetIDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserActionSetID.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserActionSetIDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserActionSetIDValidationError{}

// Validate checks the field values on AccountSetting_PddConfig with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AccountSetting_PddConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AccountSetting_PddConfig with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AccountSetting_PddConfigMultiError, or nil if none found.
func (m *AccountSetting_PddConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *AccountSetting_PddConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Pid

	if len(errors) > 0 {
		return AccountSetting_PddConfigMultiError(errors)
	}

	return nil
}

// AccountSetting_PddConfigMultiError is an error wrapping multiple validation
// errors returned by AccountSetting_PddConfig.ValidateAll() if the designated
// constraints aren't met.
type AccountSetting_PddConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccountSetting_PddConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccountSetting_PddConfigMultiError) AllErrors() []error { return m }

// AccountSetting_PddConfigValidationError is the validation error returned by
// AccountSetting_PddConfig.Validate if the designated constraints aren't met.
type AccountSetting_PddConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccountSetting_PddConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccountSetting_PddConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccountSetting_PddConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccountSetting_PddConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccountSetting_PddConfigValidationError) ErrorName() string {
	return "AccountSetting_PddConfigValidationError"
}

// Error satisfies the builtin error interface
func (e AccountSetting_PddConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccountSetting_PddConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccountSetting_PddConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccountSetting_PddConfigValidationError{}
