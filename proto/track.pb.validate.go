// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: track.proto

package proto

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Track with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Track) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Track with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TrackMultiError, or nil if none found.
func (m *Track) ValidateAll() error {
	return m.validate(true)
}

func (m *Track) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for AdsetId

	// no validation rules for Trackid

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TrackValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TrackValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TrackValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for EventType

	// no validation rules for ClickId

	// no validation rules for AccountId

	// no validation rules for Ip

	if all {
		switch v := interface{}(m.GetParams()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TrackValidationError{
					field:  "Params",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TrackValidationError{
					field:  "Params",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParams()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TrackValidationError{
				field:  "Params",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TrackMultiError(errors)
	}

	return nil
}

// TrackMultiError is an error wrapping multiple validation errors returned by
// Track.ValidateAll() if the designated constraints aren't met.
type TrackMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TrackMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TrackMultiError) AllErrors() []error { return m }

// TrackValidationError is the validation error returned by Track.Validate if
// the designated constraints aren't met.
type TrackValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TrackValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TrackValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TrackValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TrackValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TrackValidationError) ErrorName() string { return "TrackValidationError" }

// Error satisfies the builtin error interface
func (e TrackValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrack.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TrackValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TrackValidationError{}

// Validate checks the field values on TrackState with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TrackState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TrackState with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TrackStateMultiError, or
// nil if none found.
func (m *TrackState) ValidateAll() error {
	return m.validate(true)
}

func (m *TrackState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AdsetId

	// no validation rules for ClickId

	// no validation rules for State

	// no validation rules for Scene

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TrackStateValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TrackStateValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TrackStateValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TrackStateMultiError(errors)
	}

	return nil
}

// TrackStateMultiError is an error wrapping multiple validation errors
// returned by TrackState.ValidateAll() if the designated constraints aren't met.
type TrackStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TrackStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TrackStateMultiError) AllErrors() []error { return m }

// TrackStateValidationError is the validation error returned by
// TrackState.Validate if the designated constraints aren't met.
type TrackStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TrackStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TrackStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TrackStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TrackStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TrackStateValidationError) ErrorName() string { return "TrackStateValidationError" }

// Error satisfies the builtin error interface
func (e TrackStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrackState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TrackStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TrackStateValidationError{}

// Validate checks the field values on TrackRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TrackRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TrackRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TrackRequestMultiError, or
// nil if none found.
func (m *TrackRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TrackRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AdsetId

	// no validation rules for Trackid

	// no validation rules for EventType

	// no validation rules for ClickId

	// no validation rules for Ip

	// no validation rules for State

	// no validation rules for AccountId

	// no validation rules for Group

	if all {
		switch v := interface{}(m.GetParams()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TrackRequestValidationError{
					field:  "Params",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TrackRequestValidationError{
					field:  "Params",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParams()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TrackRequestValidationError{
				field:  "Params",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TrackRequestMultiError(errors)
	}

	return nil
}

// TrackRequestMultiError is an error wrapping multiple validation errors
// returned by TrackRequest.ValidateAll() if the designated constraints aren't met.
type TrackRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TrackRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TrackRequestMultiError) AllErrors() []error { return m }

// TrackRequestValidationError is the validation error returned by
// TrackRequest.Validate if the designated constraints aren't met.
type TrackRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TrackRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TrackRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TrackRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TrackRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TrackRequestValidationError) ErrorName() string { return "TrackRequestValidationError" }

// Error satisfies the builtin error interface
func (e TrackRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrackRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TrackRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TrackRequestValidationError{}

// Validate checks the field values on Configure with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Configure) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Configure with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConfigureMultiError, or nil
// if none found.
func (m *Configure) ValidateAll() error {
	return m.validate(true)
}

func (m *Configure) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Prompt

	// no validation rules for Mode

	// no validation rules for ScrollX1

	// no validation rules for ScrollX2

	// no validation rules for ScrollX3

	// no validation rules for StayTimeX1

	// no validation rules for StayTimeX2

	// no validation rules for StayTimeX3

	// no validation rules for RetX1

	// no validation rules for RetX2

	// no validation rules for Weixin

	// no validation rules for QrcodeUrl

	// no validation rules for Phonenumber

	// no validation rules for WebUrl

	if all {
		switch v := interface{}(m.GetM()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigureValidationError{
					field:  "M",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigureValidationError{
					field:  "M",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetM()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigureValidationError{
				field:  "M",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for StateClickId

	if m.ButtonDelay != nil {
		// no validation rules for ButtonDelay
	}

	if len(errors) > 0 {
		return ConfigureMultiError(errors)
	}

	return nil
}

// ConfigureMultiError is an error wrapping multiple validation errors returned
// by Configure.ValidateAll() if the designated constraints aren't met.
type ConfigureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigureMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigureMultiError) AllErrors() []error { return m }

// ConfigureValidationError is the validation error returned by
// Configure.Validate if the designated constraints aren't met.
type ConfigureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigureValidationError) ErrorName() string { return "ConfigureValidationError" }

// Error satisfies the builtin error interface
func (e ConfigureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigure.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigureValidationError{}

// Validate checks the field values on JumpSchema with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *JumpSchema) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JumpSchema with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in JumpSchemaMultiError, or
// nil if none found.
func (m *JumpSchema) ValidateAll() error {
	return m.validate(true)
}

func (m *JumpSchema) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	// no validation rules for Weburl

	// no validation rules for Minilink

	if len(errors) > 0 {
		return JumpSchemaMultiError(errors)
	}

	return nil
}

// JumpSchemaMultiError is an error wrapping multiple validation errors
// returned by JumpSchema.ValidateAll() if the designated constraints aren't met.
type JumpSchemaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JumpSchemaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JumpSchemaMultiError) AllErrors() []error { return m }

// JumpSchemaValidationError is the validation error returned by
// JumpSchema.Validate if the designated constraints aren't met.
type JumpSchemaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JumpSchemaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JumpSchemaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JumpSchemaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JumpSchemaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JumpSchemaValidationError) ErrorName() string { return "JumpSchemaValidationError" }

// Error satisfies the builtin error interface
func (e JumpSchemaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJumpSchema.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JumpSchemaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JumpSchemaValidationError{}

// Validate checks the field values on ClickState with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClickState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClickState with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClickStateMultiError, or
// nil if none found.
func (m *ClickState) ValidateAll() error {
	return m.validate(true)
}

func (m *ClickState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClickId

	// no validation rules for State

	if len(errors) > 0 {
		return ClickStateMultiError(errors)
	}

	return nil
}

// ClickStateMultiError is an error wrapping multiple validation errors
// returned by ClickState.ValidateAll() if the designated constraints aren't met.
type ClickStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClickStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClickStateMultiError) AllErrors() []error { return m }

// ClickStateValidationError is the validation error returned by
// ClickState.Validate if the designated constraints aren't met.
type ClickStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClickStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClickStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClickStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClickStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClickStateValidationError) ErrorName() string { return "ClickStateValidationError" }

// Error satisfies the builtin error interface
func (e ClickStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClickState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClickStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClickStateValidationError{}

// Validate checks the field values on TrackResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TrackResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TrackResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TrackResponseMultiError, or
// nil if none found.
func (m *TrackResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TrackResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Resp.(type) {
	case *TrackResponse_Empty:
		if v == nil {
			err := TrackResponseValidationError{
				field:  "Resp",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEmpty()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TrackResponseValidationError{
						field:  "Empty",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TrackResponseValidationError{
						field:  "Empty",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEmpty()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TrackResponseValidationError{
					field:  "Empty",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TrackResponse_Config:
		if v == nil {
			err := TrackResponseValidationError{
				field:  "Resp",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TrackResponseValidationError{
						field:  "Config",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TrackResponseValidationError{
						field:  "Config",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TrackResponseValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TrackResponse_Schema:
		if v == nil {
			err := TrackResponseValidationError{
				field:  "Resp",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSchema()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TrackResponseValidationError{
						field:  "Schema",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TrackResponseValidationError{
						field:  "Schema",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSchema()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TrackResponseValidationError{
					field:  "Schema",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TrackResponse_State:
		if v == nil {
			err := TrackResponseValidationError{
				field:  "Resp",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetState()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TrackResponseValidationError{
						field:  "State",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TrackResponseValidationError{
						field:  "State",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetState()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TrackResponseValidationError{
					field:  "State",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return TrackResponseMultiError(errors)
	}

	return nil
}

// TrackResponseMultiError is an error wrapping multiple validation errors
// returned by TrackResponse.ValidateAll() if the designated constraints
// aren't met.
type TrackResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TrackResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TrackResponseMultiError) AllErrors() []error { return m }

// TrackResponseValidationError is the validation error returned by
// TrackResponse.Validate if the designated constraints aren't met.
type TrackResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TrackResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TrackResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TrackResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TrackResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TrackResponseValidationError) ErrorName() string { return "TrackResponseValidationError" }

// Error satisfies the builtin error interface
func (e TrackResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrackResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TrackResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TrackResponseValidationError{}

// Validate checks the field values on ActionParams with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ActionParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActionParams with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ActionParamsMultiError, or
// nil if none found.
func (m *ActionParams) ValidateAll() error {
	return m.validate(true)
}

func (m *ActionParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Staytime != nil {
		// no validation rules for Staytime
	}

	if m.ScrollPercent != nil {
		// no validation rules for ScrollPercent
	}

	if m.Url != nil {
		// no validation rules for Url
	}

	if m.Referrer != nil {
		// no validation rules for Referrer
	}

	if m.Weixin != nil {
		// no validation rules for Weixin
	}

	if m.Position != nil {
		// no validation rules for Position
	}

	if m.UserAgent != nil {
		// no validation rules for UserAgent
	}

	if m.ProductName != nil {
		// no validation rules for ProductName
	}

	if m.ProductPrice != nil {
		// no validation rules for ProductPrice
	}

	if m.ProductTotal != nil {
		// no validation rules for ProductTotal
	}

	if m.ProductQuantity != nil {
		// no validation rules for ProductQuantity
	}

	if m.Phonenumber != nil {
		// no validation rules for Phonenumber
	}

	if m.M != nil {

		if all {
			switch v := interface{}(m.GetM()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionParamsValidationError{
						field:  "M",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionParamsValidationError{
						field:  "M",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetM()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionParamsValidationError{
					field:  "M",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Scene != nil {
		// no validation rules for Scene
	}

	if len(errors) > 0 {
		return ActionParamsMultiError(errors)
	}

	return nil
}

// ActionParamsMultiError is an error wrapping multiple validation errors
// returned by ActionParams.ValidateAll() if the designated constraints aren't met.
type ActionParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionParamsMultiError) AllErrors() []error { return m }

// ActionParamsValidationError is the validation error returned by
// ActionParams.Validate if the designated constraints aren't met.
type ActionParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActionParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActionParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionParamsValidationError) ErrorName() string { return "ActionParamsValidationError" }

// Error satisfies the builtin error interface
func (e ActionParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActionParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionParamsValidationError{}

// Validate checks the field values on GyroscopeParams with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GyroscopeParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GyroscopeParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GyroscopeParamsMultiError, or nil if none found.
func (m *GyroscopeParams) ValidateAll() error {
	return m.validate(true)
}

func (m *GyroscopeParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for X

	// no validation rules for Y

	// no validation rules for Z

	if len(errors) > 0 {
		return GyroscopeParamsMultiError(errors)
	}

	return nil
}

// GyroscopeParamsMultiError is an error wrapping multiple validation errors
// returned by GyroscopeParams.ValidateAll() if the designated constraints
// aren't met.
type GyroscopeParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GyroscopeParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GyroscopeParamsMultiError) AllErrors() []error { return m }

// GyroscopeParamsValidationError is the validation error returned by
// GyroscopeParams.Validate if the designated constraints aren't met.
type GyroscopeParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GyroscopeParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GyroscopeParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GyroscopeParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GyroscopeParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GyroscopeParamsValidationError) ErrorName() string { return "GyroscopeParamsValidationError" }

// Error satisfies the builtin error interface
func (e GyroscopeParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGyroscopeParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GyroscopeParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GyroscopeParamsValidationError{}

// Validate checks the field values on PixelRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PixelRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PixelRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PixelRequestMultiError, or
// nil if none found.
func (m *PixelRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PixelRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Trackid

	if len(errors) > 0 {
		return PixelRequestMultiError(errors)
	}

	return nil
}

// PixelRequestMultiError is an error wrapping multiple validation errors
// returned by PixelRequest.ValidateAll() if the designated constraints aren't met.
type PixelRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PixelRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PixelRequestMultiError) AllErrors() []error { return m }

// PixelRequestValidationError is the validation error returned by
// PixelRequest.Validate if the designated constraints aren't met.
type PixelRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PixelRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PixelRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PixelRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PixelRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PixelRequestValidationError) ErrorName() string { return "PixelRequestValidationError" }

// Error satisfies the builtin error interface
func (e PixelRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPixelRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PixelRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PixelRequestValidationError{}

// Validate checks the field values on PixelResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PixelResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PixelResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PixelResponseMultiError, or
// nil if none found.
func (m *PixelResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PixelResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Image

	// no validation rules for Trackid

	if len(errors) > 0 {
		return PixelResponseMultiError(errors)
	}

	return nil
}

// PixelResponseMultiError is an error wrapping multiple validation errors
// returned by PixelResponse.ValidateAll() if the designated constraints
// aren't met.
type PixelResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PixelResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PixelResponseMultiError) AllErrors() []error { return m }

// PixelResponseValidationError is the validation error returned by
// PixelResponse.Validate if the designated constraints aren't met.
type PixelResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PixelResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PixelResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PixelResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PixelResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PixelResponseValidationError) ErrorName() string { return "PixelResponseValidationError" }

// Error satisfies the builtin error interface
func (e PixelResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPixelResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PixelResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PixelResponseValidationError{}

// Validate checks the field values on Pushed with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Pushed) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Pushed with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PushedMultiError, or nil if none found.
func (m *Pushed) ValidateAll() error {
	return m.validate(true)
}

func (m *Pushed) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for AdsetId

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PushedValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PushedValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PushedValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPushAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PushedValidationError{
					field:  "PushAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PushedValidationError{
					field:  "PushAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPushAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PushedValidationError{
				field:  "PushAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDelay()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PushedValidationError{
					field:  "Delay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PushedValidationError{
					field:  "Delay",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDelay()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PushedValidationError{
				field:  "Delay",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TrackId

	// no validation rules for ClickId

	// no validation rules for AccountId

	// no validation rules for EventType

	// no validation rules for Group

	// no validation rules for StayTime

	// no validation rules for ScrollPercent

	// no validation rules for Status

	// no validation rules for UserId

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PushedValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PushedValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PushedValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Weixin

	// no validation rules for Lock

	// no validation rules for Deep

	if all {
		switch v := interface{}(m.GetM()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PushedValidationError{
					field:  "M",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PushedValidationError{
					field:  "M",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetM()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PushedValidationError{
				field:  "M",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PushedMultiError(errors)
	}

	return nil
}

// PushedMultiError is an error wrapping multiple validation errors returned by
// Pushed.ValidateAll() if the designated constraints aren't met.
type PushedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PushedMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PushedMultiError) AllErrors() []error { return m }

// PushedValidationError is the validation error returned by Pushed.Validate if
// the designated constraints aren't met.
type PushedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PushedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PushedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PushedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PushedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PushedValidationError) ErrorName() string { return "PushedValidationError" }

// Error satisfies the builtin error interface
func (e PushedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPushed.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PushedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PushedValidationError{}

// Validate checks the field values on RecordRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RecordRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RecordRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RecordRequestMultiError, or
// nil if none found.
func (m *RecordRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RecordRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AdsetId

	if len(errors) > 0 {
		return RecordRequestMultiError(errors)
	}

	return nil
}

// RecordRequestMultiError is an error wrapping multiple validation errors
// returned by RecordRequest.ValidateAll() if the designated constraints
// aren't met.
type RecordRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RecordRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RecordRequestMultiError) AllErrors() []error { return m }

// RecordRequestValidationError is the validation error returned by
// RecordRequest.Validate if the designated constraints aren't met.
type RecordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RecordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RecordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RecordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RecordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RecordRequestValidationError) ErrorName() string { return "RecordRequestValidationError" }

// Error satisfies the builtin error interface
func (e RecordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRecordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RecordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RecordRequestValidationError{}

// Validate checks the field values on RecordResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RecordResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RecordResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RecordResponseMultiError,
// or nil if none found.
func (m *RecordResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RecordResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AdsetId

	if len(errors) > 0 {
		return RecordResponseMultiError(errors)
	}

	return nil
}

// RecordResponseMultiError is an error wrapping multiple validation errors
// returned by RecordResponse.ValidateAll() if the designated constraints
// aren't met.
type RecordResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RecordResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RecordResponseMultiError) AllErrors() []error { return m }

// RecordResponseValidationError is the validation error returned by
// RecordResponse.Validate if the designated constraints aren't met.
type RecordResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RecordResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RecordResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RecordResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RecordResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RecordResponseValidationError) ErrorName() string { return "RecordResponseValidationError" }

// Error satisfies the builtin error interface
func (e RecordResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRecordResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RecordResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RecordResponseValidationError{}

// Validate checks the field values on CallbackRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CallbackRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CallbackRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CallbackRequestMultiError, or nil if none found.
func (m *CallbackRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CallbackRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Provider

	// no validation rules for Aid

	// no validation rules for Adid

	// no validation rules for AccountId

	// no validation rules for ClickId

	// no validation rules for CallbackUrl

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CallbackRequestValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CallbackRequestValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CallbackRequestValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Ip

	// no validation rules for UserAgent

	if m.Imei != nil {
		// no validation rules for Imei
	}

	if m.Idfa != nil {
		// no validation rules for Idfa
	}

	if m.Os != nil {
		// no validation rules for Os
	}

	if m.Mac != nil {
		// no validation rules for Mac
	}

	if m.Model != nil {
		// no validation rules for Model
	}

	if m.ImeiMd5 != nil {
		// no validation rules for ImeiMd5
	}

	if m.IdfaMd5 != nil {
		// no validation rules for IdfaMd5
	}

	if len(errors) > 0 {
		return CallbackRequestMultiError(errors)
	}

	return nil
}

// CallbackRequestMultiError is an error wrapping multiple validation errors
// returned by CallbackRequest.ValidateAll() if the designated constraints
// aren't met.
type CallbackRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CallbackRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CallbackRequestMultiError) AllErrors() []error { return m }

// CallbackRequestValidationError is the validation error returned by
// CallbackRequest.Validate if the designated constraints aren't met.
type CallbackRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CallbackRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CallbackRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CallbackRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CallbackRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CallbackRequestValidationError) ErrorName() string { return "CallbackRequestValidationError" }

// Error satisfies the builtin error interface
func (e CallbackRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCallbackRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CallbackRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CallbackRequestValidationError{}

// Validate checks the field values on Callback with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Callback) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Callback with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CallbackMultiError, or nil
// if none found.
func (m *Callback) ValidateAll() error {
	return m.validate(true)
}

func (m *Callback) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Provider

	// no validation rules for Aid

	// no validation rules for AdsetId

	// no validation rules for AccountId

	// no validation rules for ClickId

	// no validation rules for CallbackUrl

	// no validation rules for Ip

	// no validation rules for UserAgent

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CallbackValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CallbackValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CallbackValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CallbackValidationError{
					field:  "CreatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CallbackValidationError{
					field:  "CreatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CallbackValidationError{
				field:  "CreatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CallbackValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CallbackValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CallbackValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPushTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CallbackValidationError{
					field:  "PushTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CallbackValidationError{
					field:  "PushTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPushTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CallbackValidationError{
				field:  "PushTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Imei != nil {
		// no validation rules for Imei
	}

	if m.Mac != nil {
		// no validation rules for Mac
	}

	if m.Model != nil {
		// no validation rules for Model
	}

	if m.Idfa != nil {
		// no validation rules for Idfa
	}

	if m.ImeiMd5 != nil {
		// no validation rules for ImeiMd5
	}

	if m.IdfaMd5 != nil {
		// no validation rules for IdfaMd5
	}

	if m.Os != nil {
		// no validation rules for Os
	}

	if len(errors) > 0 {
		return CallbackMultiError(errors)
	}

	return nil
}

// CallbackMultiError is an error wrapping multiple validation errors returned
// by Callback.ValidateAll() if the designated constraints aren't met.
type CallbackMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CallbackMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CallbackMultiError) AllErrors() []error { return m }

// CallbackValidationError is the validation error returned by
// Callback.Validate if the designated constraints aren't met.
type CallbackValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CallbackValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CallbackValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CallbackValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CallbackValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CallbackValidationError) ErrorName() string { return "CallbackValidationError" }

// Error satisfies the builtin error interface
func (e CallbackValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCallback.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CallbackValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CallbackValidationError{}

// Validate checks the field values on CallbackResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CallbackResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CallbackResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CallbackResponseMultiError, or nil if none found.
func (m *CallbackResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CallbackResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CallbackResponseMultiError(errors)
	}

	return nil
}

// CallbackResponseMultiError is an error wrapping multiple validation errors
// returned by CallbackResponse.ValidateAll() if the designated constraints
// aren't met.
type CallbackResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CallbackResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CallbackResponseMultiError) AllErrors() []error { return m }

// CallbackResponseValidationError is the validation error returned by
// CallbackResponse.Validate if the designated constraints aren't met.
type CallbackResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CallbackResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CallbackResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CallbackResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CallbackResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CallbackResponseValidationError) ErrorName() string { return "CallbackResponseValidationError" }

// Error satisfies the builtin error interface
func (e CallbackResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCallbackResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CallbackResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CallbackResponseValidationError{}
